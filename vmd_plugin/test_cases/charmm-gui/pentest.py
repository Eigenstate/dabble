#!/usr/bin/env python
import argparse
import sys
import networkx as nx
import re
import numpy as np
import itertools

_s = re.compile('\s+')
_p = re.compile('(\d+)\s+(\d+)')

def lsqp(atoms):
    com = atoms.mean(axis=0)
    #u, d, v = np.linalg.svd(atoms-com)

    axes = np.zeros((len(atoms), 3))
    for i in range(len(atoms)):
        p1 = atoms[i]
        if i == len(atoms)-1:
            p2 = atoms[0]
        else:
            p2 = atoms[i+1]
        a = np.cross(p1, p2)
        axes += a
    u, d, v = np.linalg.svd(axes)
    i = 0
    d = -np.dot(v[i], com)
    n = -np.array((v[i,0], v[i,1], d))/v[i,2]
    return v[i], com, n

def intriangle(triangle, axis, u, p):
    # http://www.softsurfer.com/Archive/algorithm_0105/algorithm_0105.htm
    p1, p2, p3 = triangle
    w0 = p - p1
    a = -np.dot(axis, w0)
    b = np.dot(axis, u)
    if (abs(b) < 0.01): return False

    r = a / b
    if r < 0.0: return False
    if r > 1.0: return False

    I = p + u * r

    u = p2 - p1
    v = p3 - p1
    uu = np.dot(u, u)
    uv = np.dot(u, v)
    vv = np.dot(v, v)
    w = I - p1
    wu = np.dot(w, u)
    wv = np.dot(w, v)
    D = uv * uv - uu * vv

    s = (uv * wv - vv * wu)/D
    if (s < 0 or s > 1): return False
    t = (uv * wu - uu * wv)/D
    if (t < 0 or (s+t) > 1): return False
    return True

def build_topology(psffile):
    g = nx.Graph()
    flag = 0

    for line in open(psffile).readlines():
        if flag == 0 and line.strip().endswith('NATOM'):
            flag = 1
            continue
        if flag == 0 and line.strip().endswith('bonds'):
            flag = 2
            continue
        if flag == 1 and not line.strip(): flag = 0
        if flag == 2 and not line.strip(): break

        if flag == 1:
            num, segid, resid, resname, name = _s.split(line)[1:6]
            if resname.startswith('TIP3'): continue
            if name.startswith('H'): continue
            g.add_node(int(num), {'segid': segid, 'resname': resname, 'name': name, 'resid': resid})

        if flag == 2:
            for pair in _p.findall(line):
                num1, num2 = map(int, pair)
                if g.has_node(num1) and g.has_node(num2): g.add_edge(num1, num2)
    return g

def build_atomtable(psf, crdfile):
    crds = {}
    flag = 0
    for line in open(crdfile).readlines():
        entries = _s.split(line)
        if flag == 0 and entries[0] != '*':
            flag = 1
            continue
        if flag == 1 and not line.strip(): break

        if flag == 1:
            num, resid, resname, name, x, y, z, segid = _s.split(line.strip())[:8]
            if resname.startswith('TIP3'): continue
            if name.startswith('H'): continue
            if psf.node[int(num)]['name'] != name: raise AtomMismatch("%d %s != %d %s" % (int(num), psf.node[int(num)]['name'], int(num), name))
            crds[int(num)] = np.array((float(x), float(y), float(z)))
    return crds

class AtomMismatch(Exception):
    pass

def check_ring_penetration(psf, crd, pbc=[], verbose=0):
    # ring penetration test
    # 1. find rings
    # 2. build least square plane
    # 3. project atoms ring constituent atoms onto the plane and build convex
    # 4. find two bonded atoms that are at the opposite side of the plane
    # 5. determine the point of intersection is enclosed in the ring
    #
    molecules = nx.connected_component_subgraphs(psf)
    allatoms = np.array([crd[num] for num in psf.nodes()])
    atoms_map = np.array([num for num in psf.nodes()])
    if pbc:
        a = float(pbc[0])
        b = float(pbc[1])
        n = len(allatoms)
        allatoms = np.tile(allatoms, (8,1))
        op = ((a,0),(a,b),(0,b),(-a,b),(-a,0),(-a,-b),(0,-b),(a,-b))
        for i in range(8):
            x,y = op[i]
            allatoms[n*(i+1):n*(i+2),0] += x
            allatoms[n*(i+1):n*(i+2),1] += y
        atoms_map = np.tile(atoms_map, 8)
    pen_pairs = []
    pen_cycles = []

    for m in molecules:
        cycles = nx.cycle_basis(m)
        if not cycles: continue
        for cycle in cycles:
            flag = False
            atoms = np.array([crd[num] for num in cycle])
            if len(set([psf.node[num]['resid'] for num in cycle])) > 1: continue
            if verbose:
                num = cycle[0]
                print 'found ring:', psf.node[num]['segid'], psf.node[num]['resid'], psf.node[num]['resname']

            # build least square fit plane
            axis, com, n = lsqp(atoms)

            # project atoms to the least square fit plane
            for i,atom in enumerate(atoms):
                w = np.dot(axis, atom-com)*axis + com
                atoms[i] = com + (atom - w)

            maxd = np.max(np.sqrt(np.sum(np.square(atoms - com), axis=1)))

            d = np.square(np.sum((allatoms-com), axis=1))
            nums = np.argwhere(d < 3)
            nums = np.reshape(nums, len(nums))

            # find two bonded atoms that are at the opposite side of the plane
            for num in nums:
                num1 = atoms_map[num]

                for num2 in psf[num1]:
                    if num1 in cycle or num2 in cycle: continue
                    crd1 = crd[num1]
                    crd2 = crd[num2]

                    v1 = np.dot(crd1 - com, axis)
                    v2 = np.dot(crd2 - com, axis)
                    if v1 * v2 > 0: continue

                    # point of intersection of the least square fit plane
                    s = -np.dot(axis, crd1-com)/np.dot(axis, crd2-crd1)
                    p = crd1 + s*(crd2-crd1)

                    d = np.sqrt(np.sum(np.square(p-com)))
                    if d > maxd: continue
                    if verbose:
                        print 'found potentially pentrarting bond:', psf.node[num1]['segid'], psf.node[num1]['resid'], psf.node[num1]['resname'], psf.node[num1]['name'], psf.node[num2]['name']

                    d = 0
                    for i in range(0, len(atoms)):
                        p1 = atoms[i] - p
                        try: p2 = atoms[i+1] - p
                        except: p2 = atoms[0] - p
                        d += np.arccos(np.dot(p1, p2)/np.linalg.norm(p1)/np.linalg.norm(p2))

                    wn = d/2/np.pi
                    if wn > 0.9 and wn < 1.1:
                        # we have a case
                        pen_pairs.append((num1, num2))
                        pen_cycles.append(cycle)
                        flag = True
                        break

                if flag: break

    return pen_pairs, pen_cycles

def find_alpha_shape(atoms, alpha=-1, verbose=0):
    # build alpha-shape of the protein
    # requires Ken Clarkson's Hull program
    # http://netlib.sandia.gov/voronoi/hull.html
    import subprocess as sp
    pid = sp.Popen(['hull.exe', '-A', '-oN'], stdin=sp.PIPE, stdout=sp.PIPE, stderr=sp.PIPE, close_fds=True) # Delaunay triangulation
    pid.communicate("\n".join(["%12.8f %12.8f %12.8f" % tuple(atom) for atom in atoms]))

    flag = False
    facets = []
    facets_crds = []
    vertices = set([])
    h = nx.Graph()
    for line in open('hout-alf').readlines():
        if flag:
            i, j, k = map(int, line.strip().split())
            facets.append((i, j, k))
            facets_crds.append(np.array((atoms[i], atoms[j], atoms[k])))
            [vertices.add(x) for x in (i,j,k)]
            h.add_edges_from([(i, j), (i, k), (j, k)])
        if line.startswith("%hull"): flag = True
    facets_crds = np.array(facets_crds)
    return h, facets_crds

def check_protein_penetration(psf, crds, verbose=0, output=0):
    # protein penetration test
    # 1. build alpha-shape of the protein based on the CA and CB atoms within 6A
    # 2. find two atoms that placed opposite side of the hull
    #

    prot_atoms = np.array([crds[num] for num in psf.nodes() if psf.node[num]['name'] in ['CA', 'CB']])
    prot_segids = set([psf.node[num]['segid'] for num in psf.nodes() if psf.node[num]['name'] == 'CA'])
    pen_pairs = []
    if len(prot_atoms) == 0: return pen_pairs

    g, facets_crds = find_alpha_shape(prot_atoms, verbose)

    if output:
        fp = open(output, 'w')
        for node in g.nodes():
            x, y, z = prot_atoms[node]
            fp.write("HETATM%5d  %-3s %3s  %4d    %8.3f%8.3f%8.3f  0.00  0.00      \n" % (node, 'C', 'DUM', node, x, y, z))

        for edge in g.edges():
            fp.write("CONECT%5d%5d\n" % edge)

    dist = lambda x,y: np.sqrt(np.sum(np.square(x - y)))
    flag = False

    # find atoms potentially protruding the alpha-surface of the protein
    xmax, xmin = np.max(prot_atoms[:,0]), np.min(prot_atoms[:,0])
    ymax, ymin = np.max(prot_atoms[:,1]), np.min(prot_atoms[:,1])
    visited = []
    for node in psf.nodes():
        if psf.node[node]['segid'] in prot_segids: continue
        if node in visited: continue
        crd = crds[node]
        if ((crd[0] > (xmax+3) or crd[0] < (xmin-3)) and
            (crd[1] > (ymax+3) or crd[1] < (ymin-3))): continue
        if np.min(np.sum(np.square(facets_crds[:,0]-crd), axis=1)) > 25: continue

        # closest facet
        d = np.sum(np.square((np.sum(facets_crds, axis=1)/3) - crd), axis=1)
        if np.min(d) > 3: continue
        close_facets = np.argwhere(d < 3)
        if len(close_facets) == 0: continue
        close_facets = np.reshape(close_facets, (len(close_facets)))

        num1 = node
        u = []
        crd1 = np.array(crds[num1])
        for num2 in psf[num1]:
            crd2 = np.array(crds[num2])
            u.append((num2, crd2-crd1))

        flag = False
        for i in close_facets:
            facet = facets_crds[i]
            p1 = np.array(facet[0])
            p2 = np.array(facet[1])
            p3 = np.array(facet[2])
            triangle = np.array((p1, p2, p3))
            axis = np.cross(p2-p1, p3-p1)

            for num2, r in u:
                if not intriangle(triangle, axis, r, crd1): continue
                else:
                    # we have a case
                    pen_pairs.append((num1, num2))
                    visited.append(num1)
                    visited.append(num2)
                    flag = True
                    break
            if flag: break

    return pen_pairs

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('psf', metavar='psffile', help='PSF file')
    parser.add_argument('crd', metavar='crdfile', help='CRD file')
    parser.add_argument('-pbc', dest='pbc', nargs=2, help='PBC option (needs A and B values)')
    parser.add_argument('-v', dest='verbose', action='store_true')
    parser.add_argument('-o', dest='output', help='Visualize alpha shape', default=None)
    args = parser.parse_args()

    # build connectivity of atoms
    psf = build_topology(args.psf)
    crd = build_atomtable(psf, args.crd)

    # sanity check
    if len(psf.nodes()) != len(crd): raise AtomMismatch('Number of atom does not match')

    print '%lipid ring penetration'
    pairs, rings = check_ring_penetration(psf, crd, pbc=args.pbc, verbose=args.verbose)
    if pairs:
        #print 'found a ring penetration:'
        #for cycle in rings:
        #    print '- %s %s %s %s' % (psf.node[cycle[0]]['segid'], psf.node[cycle[0]]['resid'], psf.node[cycle[0]]['resname'], ' '.join([psf
        for pair in pairs:
            print psf.node[pair[0]]['segid'], psf.node[pair[0]]['resid']

    print '%protein surface penetration'
    pairs = check_protein_penetration(psf, crd, verbose=args.verbose, output=args.output)
    if pairs:
        #print 'found a protein penetration:'
        for pair in pairs:
            print psf.node[pair[0]]['segid'], psf.node[pair[0]]['resid']
        #for pair in pairs:
        #    print '- %s %s %s %s %s' % (psf.node[pair[0]]['segid'], psf.node[pair[0]]['resid'], psf.node[pair[0]]['resname'], psf.node[pair


if __name__ == '__main__':
    main()
