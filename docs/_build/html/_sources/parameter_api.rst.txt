.. highlight:: python
.. _parameter_api:

Parameterization with Dabble
============================

Regardless of simulation program or force field, parameterizing a 
molecular system consists of several steps:

   1) Parse the library of known residues provided by the forcefield
   2) `Match system residues`_ to those in library
   3) Assign residue and atom names based on matching
   4) `Invoke simulation package preparatory program`_ to build
      input files.

Pretty much all simulation package prepatory programs require that
atom names match the defined residue types, and cannot match up for
you. This resuls in many awkward work arounds, such as large dictionaries
of name translations for each amino acid from RSC PDB names to the
required ones, and tedious work on the part of the user for ligands.

Dabble does all of this work for you, and is in fact completely 
agnostic to the atom names in the input file. It does this by representing
each residue as an undirected graph, with nodes being atoms. A library
of these graphs is generated from provided parameter and topology files,
and graph isomorphism is used to match up system residues to those in the
library based on element.

As protein residues are in a long chain, the graph representation is
a little trickier. Using the same philosophy as the CHARMM and AMBER
parameter sets, "special" atoms called `+` and `-` are attached to represent
the next and previous amino acid in the chain. This does require that
all protein residues are correctly represented in the input file, that
is, each resid does correspond to an entire amino acid.

There are several tweaks to this process depending on the desired output
format. For example, CHARMM has the concept of "patches" that can be applied
on top of residues. Dabble can detect and apply these correctly. 

The following API functions are called on the built system from
Dabble's builder, but you can use them on systems you have already
built as well, or extend them to other systems.

.. _Match system residues:

Automatic atom naming
---------------------

Atom matching classes inherit from ``MoleculeMatcher``, which
defines basic functionality for matching:

.. autoclass:: dabble.param.MoleculeMatcher
    :members:
    :show-inheritance:

.. _Invoke simulation package preparatory program:

Generation of simulation input files
------------------------------------

Simulation input files are generated by a preparatory program specific
to that package. Dabble invokes this program instead of generating files
itself as functionality may change, and application of correct forcefield
parameters can be challenging. Also, there is no reason to reinvent the wheel.

For CHARMM, Dabble invokes the VMD plugin `psfgen`, and for AMBER, `tleap`.
Dabble generates an input file for these programs, invokes them, and
checks the output for correctness.

The design philosophy here is that this should be accomplished by a 
``Writer`` class, that when initialized with a VMD molecule ID corresponding
to the built system  as well as parameter and/or topology files to be applied.
It invokes the atom matching, then generates a new molecule
with corrected atom and residue names. Invoking ``Writer.write`` with an
output file name then generates an input file for and calls the setup program,
checking the output along the way. 

Amber-specific Parameterization
-------------------------------

Atom name matching in AMBER has functionality specific to the
modular head/tail representation of lipids, as well as identification
of disulfide bonds.

.. autoclass:: dabble.param.AmberMatcher
    :members:
    :show-inheritance:

The ``AmberWriter`` class requires an installation of AmberTools in
``$AMBERHOME``, enabling the use of the most up to date forcefields and
bugfixes. The following parameter and topology sets are used by default::

    - leaprc.protein.ff14SB
    - leaprc.lipid14
    - leaprc.lipid16
    - leaprc.water.tip3p
    - leaprc.gaff2

The `tleap` program is used to do the parameterization, and the ParmEd
API then applies HMR if desired, and checks the result.

If the user is asking for input files for AMBER using CHARMM parameters,
the ``AmberWriter`` class can also take the molecule ID of a
CHARMM-parameterized molecule, and invoke ``chamber`` through the ParmEd
API to convert to the AMBER format.

.. autoclass:: dabble.param.AmberWriter
    :members:
    :show-inheritance:

Charmm-specific Parameterization
--------------------------------

Atom name matching in CHARMM is somewhat complicated by the fact that
patches are allowed. Patches represent modifications to residues, and
may be applied to any residue although in reality are only chemically
valid for a subset of them. An example of a patch is the addition of
a disulfide bond between two residues (DISU), or a cap on the N-terminal
end of the protein (NTER, ACE).

If a residue cannot be matched from the provided topology definitions,
Dabble's graph matching functionality generates a library of valid
patch applications and attempts to match there, adding the relevant
patches if a match is found. Subgraph isomorphism is used to help
trim the size of this library.

With the exception of disulfide bonds,
patches involving only one residue are currently supported.

Note that this requires patch atoms to be in the same residue. This
can pose a challenge to recognition of caps, which are applied as
separate residues in some protein preparation workflows (notably 
Maestro).

.. autoclass:: dabble.param.CharmmMatcher
    :members:
    :show-inheritance:

The VMD plugin `psfgen <http://www.ks.uiuc.edu/Research/vmd/plugins/psfgen/>`_ is
used to generate parameterized files with CHARMM parameters. Dabble uses the
`Python interface to psfgen <https://psfgen.robinbetz.com>`_ to invoke this
code, and handles all its quirks (such as not allowing segments
to have more than 10,000 atoms because its PDB parser is the worst).

.. autoclass:: dabble.param.CharmmWriter
    :members:
    :show-inheritance:

